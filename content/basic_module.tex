\section{Basic module}

  \subsection{install and import module}
    \subsubsection{install and manage modules}
      可以通过pip安装和管理所需的module。
      \begin{codeblock}[language=bash, caption={download modules}]
        pip install pandas  #安装module
        pip uninstall pandas  #卸载安装的module
        pip list #列出所有已安装的module，可选-o查看是否是最新版本
        pip install -U pandas #更新module
        pip freeze --local | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U
        pip search pandas #搜索指定的module
        pip freeze > requirements.txt #将项目所需的module整理成文档
        pip install -r requirements.txt #将文件中的module全部安装下来
      \end{codeblock}

    \subsubsection{virtualenv}
      virtualenv是指项目运行的module环境，这个环境可以不包含global环境中的所有module。
      \begin{codeblock}[language=bash, caption={setup virtualenv}]
        pip install virtualenv 
        mkdir Environments
        cd Environments
        virtualenv project1_env -p /usr/bin/python3.10 #创建virtualenv环境，python版本可选
        source project1_env/bin/activate #activate virtualenv
        pip install numpy #这里下载所需的module即可
        pip install -r requirements.txt #由文件下载所有module 
        pip freeze --local > requirements.txt #将virtualenv中的module整理成文档
        deactivate #退出virtualenv
        rm -rf project1_env #删除已创建的virtualenv环境
      \end{codeblock}

    \subsubsection{pipenv}
      管理环境是很有必要的，若所有项目都在base环境中运行，package的更新可能导致项目不可用。

      pipenv结合了pip和virtualenv，可以用来管理代码运行环境。
      pipenv由packages(生产环境运行必须有的包)，dev-packages(开发环境所需的包)

      Pipfile列出了基本信息，Pipfile.lock是决定性的，列出了具体信息。
      \begin{codeblock}[language=python, caption={pipenv}]
        pipenv install requests #向package中添加module，环境保存在Pipfile中
        pipenv install pytest --dev #向dev中添加module
        pipenv uninstall requests #删除module

        pipenv install #安装Pipfile中的所有module
        pipenv install --ignore-pipfile #安装Pipfile.lock中的所有module
        pipenv install -r requirement.txt #利用文件加载环境
        pipenv graph #列出环境内容，包括依赖关系
        pipenv lock -r > requirements.txt #整理环境内容
        pipenv lock #更新pip.lock

        pipenv --python 3.6 #修改python版本，直接修改Pipfile不会修改环境
        pipenv --rm #删除环境，不会删除Pipfile
        pipenv install #由Pipfile重建环境
        pipenv --venv #查看虚拟环境目录
        pipenv check #检查是否能更新，Pipfile和环境是否对应

        pipenv shell #激活环境
        pipenv run python #在环境里运行指令(打开python)
        exit #退出环境 

        touch .env #这个文件可以设置独属于这个环境的环境变量
      \end{codeblock}

      \begin{codeblock}[language=python, caption={.env}]
        SECRET_KEY="MySuperSecretKey" #局部环境变量
      \end{codeblock}

    \subsubsection{anaconda}
      anaconda也可以用来管理module和环境，其效果相当于pip+virtualenv。
      anaconda的优势在于可以安装不属于python的module，且可提供图形化管理功能。

      注意，anaconda和pipenv有冲突，不能一起使用。
      \begin{codeblock}[language=bash, caption={anaconda}]
        conda create --name my_app python=2.7 flask sqlalchemy
        #创建一个名为my\_app的项目，项目环境中带有flask和sqlalchemy，python版本为2.7
        conda activate my_app #激活环境，默认环境为base
        conda deactivate #退出环境
        conda env list #列出所有已创建的环境 
        conda remove --name my_app --all #删除已有的环境
        conda env export > environment.yaml #导出environment的内容
        conda env export create -f environment.yaml #通过文件创建环境
      \end{codeblock}

      有时我们需要记录环境与对应项目的目录，这是我们可以在环境目录(可以通过conda env list查看)
      etc/conda/activate.d/env\_vars.sh，etc/conda/deactivate.d/env\_vars.sh，这两个
      文件分别会在activate和deactivate时自动运行。
      \begin{codeblock}[language=bash, caption={activate.d/env\_vars.sh}]
        #!/bin/sh
        export DATABASE_URI="postgresql://user:pass@db_server:5432/test_db"
        #just add anything you need
      \end{codeblock}
      \begin{codeblock}[language=bash, caption={deactivate.d/env\_vars.sh}]
        #!/bin/sh
        unset DATABASE_URI
      \end{codeblock}

      可以通过\~{}/.bashrc中加入以下函数以自动启用文件夹中的environment.yaml。
      \begin{codeblock}[language=bash, caption={conda\_auto\_env}, mathescape=false]
        function conda_auto_env() {
          if [ -e "environment.yaml" ]; then
            ENV_NAME=$(head -n 1 environment.yaml | cut -f2 -d " ") 
            #Check if you are already in the environment
            if [[ $CONDA_PREFIX != *$ENV_NAME* ]]; then
                #Try to activate environment
                conda activate $ENV_NAME &>/dev/null
            fi
          fi
        }

        #export PROMPT\_COMMAND="conda\_auto\_env;\$PROMPT\_COMMAND"
        #\$PROMPT\_COMMAND每次按下enter时都会运行，若不需要，可以注释掉最后一行，并使用conda\_auto\_env手动调用环境
      \end{codeblock}

    \subsubsection{import modules}
      \begin{codeblock}[language=python, caption={import module}]
        import math
        import math as ma
        from math import sqrt
        from math import *
      \end{codeblock}

    \subsubsection{view the functions in modules}
      \begin{codeblock}[language=python, caption={view the functions in builtin module}]
        import builtins
        print(dir(builtins)) #这个查看方法对所有module都有效
      \end{codeblock}

    \subsubsection{circular import}
      circular import是一个常见的错误。当main.py import B.py的其中部分时，B.py整个文件都会被运行，
      若B.py同样import main，那么A.py也会从头开始运行整个文件，而这时main.py会找不到其import B.py中的部分，
      这时就触发了circular import。

  \subsection{builtins}
    最基础的module，包含了print len range abs等常用函数，TypeError ValueError KeyError IndexError
    等常见异常，True False None等内置常量，int str list dict set等内置类型，不需要导入即可使用。

  \subsection{sys}
    有关系统操作的module
    \begin{codeblock}[language=python, caption={sys module}]
      print(sys.path)
      #系统路径列表，可以通过append追加module所在地址
      #也可以追加在~/.bashrc的PYTHONPATH里面(作为环境变量)
      #如果需要import的module是一个文件夹，需要保证文件夹中有一个'\_\_init\_\_.py'文件
      #'\_\_init\_\_.py'文件会在import时运行，该文件可以为空，也可以导入文件夹中的子模块
      print(sys.executable) #输出python的文件位置
      print(sys.version) #输出python版本，用来检验编译器
    \end{codeblock}

  \subsection{os}
    os module可以实现操作系统相关的功能。
    \begin{codeblock}[language=python, caption={os module}]
      #文件管理
      os.getcwd() #输出工作区目录
      os.chdir('/mnt/d/Desktop') #移动到指定目录
      os.listdir() #输出当前目录下的所有文件及文件夹
      os.mkdir('os_test') #在当前目录下新建，注意只能新建一层
      os.makedirs('os_test/my_profile') #新建目录，允许多层
      os.rmdir('os_test'); os.removedirs('os_test/myprofile') #删除目录
      os.rename('test.txt', 'demo.txt') #重命名文件
      print(os.stat('demo.txt')) #查看文件属性，如文件大小(st\_size)，最后一次修改时间(st\_mtime)
      for dirpath, dirnames, filenames in os.walk(/mnt/d/Desktop/python) #递归的遍历目录下所有文件
          if f.endswith('.py): #筛出所有python脚本文件
      #dirpath表示当前所在的目录，dirname表示当前目录下的文件夹，filenames表示当前目录下的文件名

      os.environ.get('HOME') #返回home的地址，这里还可以查询其他环境变量，如PATH
      os.path.join(os.environ.get('HOME"), 'test.txt') #拼接目录，直接字符串相加容易遗漏或多加slash
      os.path.exists('/mnt/d/test.txt') #返回一个bool值，即目录是否存在
      os.path.basename('/mnt/d/test.txt') #返回`test.txt'这里无论路径是否存在都不会报错
      os.path.dirname('/mnt/d/test.txt') #返回`/mnt/d'
      os.path.split('/mnt/d/test.txt') #返回(`/mnt/d', 'test.txt')
      os.path.splitext('/mnt/d/test.txt') #返回(`/mnt/d/test',`.txt')
    \end{codeblock}

  \subsection{logging}
    logging module是python标准库中用于记录日志的模块，它可以在程序运行时输出各种级别的日志。
    \begin{codeblock}[language=python, caption={logging module}]
      #basicConfig用于设置日志的基本信息，这会设置root logger，影响所有的logger
      logging.basicConfig(filename='app.log', filemode='w', 
                  level=logging.DEBUG, #默认是WARNING
                  format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', 
                  datefmt='%Y-%m-%d %H:%M:%S'
                      #format的更多选项见\href{https://docs.python.org/3/library/logging.html#logrecord-attributes}{\underline{LogRecord attributes}}
                  )
      #注意，多次设置root logger只有第一个生效，这在导入文件时要特别注意

      #可以使用handlers将日志同时输出到多个文件或输出到控制台
      logging.basicConfig(
          level=logging.INFO,
          format='%(asctime)s - %(levelname)s - %(message)s',
          handlers=[
              logging.FileHandler("logfile.log"),   # 文件处理器
              logging.StreamHandler()               # 控制台处理器
          ]
      )

      #为了让每个文件有单独的logging文件和等级，可以在每个文件里单独设置logger
      logger = logging.getLogger(__name__) #一般以\_\_name\_\_作为logger的命名
      logger.setLevel(logging.INFO) #设置logger的level
      file_handler = logging.FileHandler('test.log') #设置日志文件和格式
      file_handler.setFormatter(logging.Formatter('%(levelname)s:%(name)s:%(message)s'))
      logger.addHandler(file_handler) #将logger的内容输出到文件中
      string_handler = logging.StreamHandler()
      string_handler.setFormatter(logging.Formatter('%(levelname)s:%(name)s:%(message)s'))
      logger.addHandler(string_handler) #将logger的内容输出到终端

      #以下信息将会以上面设定的形式存到app.log文件中，只有level以上级别会显示出来
      logging.debug("这是调试信息")
      logging.info("这是一般信息")
      logging.warning("这是警告信息")
      logging.error("这是错误信息")
      logging.critical("这是严重错误信息")

      #若为每个文件单独设置了logger，则可以这样调用
      logger.info("这是一般信息")

      #error等级的错误可以添加报错信息，即traceback
      logging.exception("这是一条带有Traceback的错误信息")
    \end{codeblock}

  \subsection{date}
    \subsubsection{datetime module}
      datetime用于时间和日期戳记录和转换
      \begin{codeblock}[language=python, caption={datetime \& pytz}]
        d = datetime.date(2020, 7, 24); print(d) #这里的day是一个date类型的变量
        td = datetime.date.today() #输出今天的日期
        print(d.year); print(d.month); print(d.day)
        print(d.weekday()); print(tday.isoweekday()) 
        #in weekday: Monday 0 Sunday 6, in isoweekday: Monday 1 Sunday 7
        tdelta = datetime.timedelta(days = 7) #这里tdelta是timedelta类型的，可以参与加减法
        date2 = date1 + timedelta; timedelta = date1 - date2
        tdelta.total_seconds() #时间差转秒

        t = datetime.time(9, 30, 45, 100000) #四个参数分别是h m s $\mu$s
        print(t.hour); print(t.minute); print(t.second); print(t.microsecond)
        print(t.iosformat()) #以国际标准形式输出时间
        print(t.strftime('%B %d, %Y')) #以自定义形式输出时间，这里可以参考\href{https://docs.python.org/3/library/datetime.html\#strftime-strptime-behavior}{\underline{strftime官方文档}}

        dt = datetime.datetime.strptime('July 26, 2016', '%B %d, %Y') #根据模板由string转datetime
        dt = datetime.datetime(2020, 7, 8, 12, 10, 32, 100000, tz = pytz.UTC) #时区可选
        t = dt.time(); d = dt.date(); print(dt.year)
        sentence = f'Jack has a birthday on {birthday:%B %d, %Y}' #结合fstring使用
      \end{codeblock}

    \subsubsection{pytz module}
      pytz用于管理时区(time zone)相关的信息。
      \begin{codeblock}[language=python, caption={pytz module}]
        dt_today = datetime.datetime.today() #返回当前时区的时间
        dt_now = datetime.datetime.now(tz = pytz.UTC) #返回指定时区的时间，默认没有时区信息
        dt_utcnow = datetime.datetime.utcnow() #返回utc时间，不建议使用
        dt_mtn = dt_now.astimezone(pytz.timezone('Asia/Shanghai')) 
        #需要带有时区参数的datetime变量才可以进行时区转换
        for tz in pytz.all_timezones:
          print(tz)  #输出所有的时区名称
        dt_mtn = pytz.timezone('America/New_York').localize(dt_today) #为时间添加时区
        dt_time = datetime.datetime.fromtimestamp(mod_time) #将时间戳转换成datetime类型
      \end{codeblock}

    \subsubsection{calendar}
      calendar用于计算天数，星期数，星期几等数据。
      \begin{codeblock}[language=python, caption={calendar module}]
        today = datetime.date.today()
        days_in_current_month = calendar.monthrange(today.year, today.month)
        #输出一个tuple，第一个元素表示今天星期几Monday0 Sunday6，第二个表示本月有几天
      \end{codeblock}

  \subsection{time}
    time module可以用于计时
    \begin{codeblock}[language=python, caption={time module}]
      t = time.time() #返回linux时间戳，单位都是秒
      t1 = time.perf_counter(); t2 = time.perf_counter() #高精度时间计数器
      t3 = time.process_time(); t4 = time.process_time() #高精度的CPU时间
      print(t2 - t1) #计算时间差，会包含sleep()的时间
      print(t4 - t3) #计算时间差，不会包含sleep()的时间
    \end{codeblock}

  \subsection{PIL}
    PIL module可以处理图片，module中的具体内容见\href{https://pillow-cn.readthedocs.io/zh-cn/latest/}{\underline{PIL官方文档}}。
    \begin{codeblock}[language=python, caption={PIL}]
      from PIL import Image, ImageFilter

      image1 = Image.open('pup1.jpg')
      image1.save('pup1.png')
      image1.show() #显示图片

      image1.thumbnail((300, 300)) #压缩至300*300像素
      image1.rotate(90) #逆时针旋转$90^{\circ}$
      image1.convert(mode='L') #图片变黑白

      image1.filter(ImageFilter.GaussianBlur(15)) #模糊图片，模糊程度可选
    \end{codeblock}

  \subsection{random}
    \begin{codeblock}[language=python, caption={random module}]
      value = random.random() #生成[0.0, 1.0)的随机浮点数
      value = random.uniform(1, 10) #生成[1.0, 10.0]的随机浮点数
      value = random.randint(1, 10) #生成[1, 10]的随机整数
      value = random.choice(['Red', 'Greed', 'Blue']) #从list中随机取出一个
      results = random.choices(['Red', 'Greed', 'Blue'], k=10) #随机取k遍，输出一个list
      results = random.choices(['Red', 'Greed', 'Blue'], weight=[18, 18, 2], k=10) 
      shuffled_list = list(range(2, 30)); random.shuffle(shuffled_list) #随机打乱list
      hand = random.sample(list(range(50)), k=5) #取5个样本，5个样本不会重复
    \end{codeblock}

  \subsection{secrets}
    secrets可以生成随机长密码。
    \begin{codeblock}[language=python, caption={secrets module}]
      import secrets
      print(secrets.token_hex(16)) #16Bytes
    \end{codeblock}

  \subsection{cn2an}
    cn2an module可以实现中文数字到阿拉伯数字的转换。
    \begin{codeblock}[language=python, caption={cn2an}]
      def chinese_to_int(chinese_str):
          arabic_number = cn2an.cn2an(chinese_str, 'normal')
          return arabic_number
    \end{codeblock}
