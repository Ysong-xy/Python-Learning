\section{regular expression}
  
  \subsection{grammar}
    正则表达式由元字符，限定符，选择字符，排除字符等组成。
    \subsubsection{元字符}
      元字符中的`.'`\$'`\^{}',限定符中的`?'`+'`*'以及`\textbackslash'若需要匹配，则应该使用转义字符。
      \begin{table}[H]
        \centering
        \caption{meta-character}
        \label{tab:meta-character}
        \begin{tabular}{cc}
          \toprule[1.5pt]
          元字符 & 匹配对象 \\
          \midrule
          . & 换行符以外的任意字符\lbrack\^{}\textbackslash n\textbackslash r\rbrack \\
          \textbackslash w & 字母、数字、下划线或汉字 \\
          \textbackslash W & 非字母、数字、下划线、汉字 \\
          \textbackslash s & 任意空白字符(\lbrack\textbackslash f\textbackslash n\textbackslash r\textbackslash t\textbackslash v\rbrack) \\
          \textbackslash S & 任意非空白字符 \\
          \textbackslash d & 数字字符 \\
          \textbackslash D & 非数字字符 \\
          \textbackslash b & 单词的边界(开始或结束) \\
          \textbackslash B & 非单词的边界 \\
          \^{} & 字符串的开始 \\
          \$ & 匹配字符串的结束 \\
          \bottomrule[1.5pt]
        \end{tabular}
      \end{table}

    \subsubsection{限定符}
      \begin{table}[H]
        \centering
        \caption{qualifier}
        \label{tab:qualifier}
        \begin{tabular}{cc}
          \toprule[1.5pt]
          限定符 & 含义 \\
          \midrule
          ? & 匹配0-1次 \\
          + & 匹配至少1次,会贪婪匹配 \\
          * & 匹配0次或多次,会贪婪匹配 \\
          +?~~*? & 匹配规则同上，但是非贪婪 \\
          \{n\} & 匹配n次 \\
          \{n,\} & 匹配至少n次 \\
          \{n,m\} & 匹配至少n次，至多m次 \\
          | & 匹配左右其一 \\
          \bottomrule[1.5pt]
        \end{tabular}
      \end{table}

    \subsubsection{brackets}
      \begin{itemize}
        \item 方括号表示字符集合，如\lbrack aeiou\rbrack 匹配元音字符，\lbrack a-z\rbrack 匹配小写字符。
          \lbrack\textbackslash u4e00-\textbackslash u9fa5\rbrack 匹配汉字。
        \item 方括号内的\^{}表示排除字符，如\lbrack\^{} aeiou\rbrack 匹配非元音字母的所有字符。
        \item 方括号中的无法使用限定符，限定符都判定为原来的字符。
        \item 小括号可以改变限定符的作用范围，如(thir|four)th相当于thirth|fourth，(\textbackslash .\lbrack 0-9\rbrack\{1,3\})\{3\}
          会将括号中的内容重复三次。
        \item 小括号还可以基于匹配模式从字符串中提取子字符串，组成一个元组。
      \end{itemize}

    \subsubsection{notice}
      Python中使用正则表达式需要将部分\textbackslash 转义,由于需要转义的\textbackslash 可能很多，可以使用模式字符串，即在字符串前加上r或R，
      例如:r`\textbackslash bm\textbackslash w*\textbackslash b'。

  \subsection{re module}
    Python中的re模块可以通过正则表达式处理字符串。
    \subsubsection{匹配模式}
      \begin{table}[H]
        \centering
        \caption{matching pattern}
        \label{tab:matching pattern}
        \begin{tabular}{cc}
          \toprule[1.5pt]
          标志 & 含义 \\
          \midrule
          A~~ASCII & 只匹配ASCII范围内的字符 \\
          I~~IGNORECASE & 不区分大小写 \\
          M~~MULTILINE & 将\^{}和\$ 用于每一行的开头和结尾 \\
          S~~DOTALL & .匹配所有字符，包括换行符 \\
          X~~VERBOSE & 忽略未转义的空格和注释 \\
          \bottomrule[1.5pt]
        \end{tabular}
      \end{table}

    \subsubsection{匹配函数}
      这里匹配的字符串区间没有重叠的部分。
      \begin{codeblock}[language=python, caption={string matching}]
        import re #导入模块

        pattern=r'mr_\w+' #模式字符串
        string='MR_SHOP mr_shop' #待匹配字符串

        #match方法可以从字符串开始处开始匹配，若匹配失败，返回None
        match=re.match(pattern,string,re.I) #不区分大小写匹配字符串,返回一个match对象
        print(match.start());print(match.end()) #输出匹配字符串起始位置
        print(match.span()) #输出匹配字符串起止位置元组
        print(match.string) #输出匹配前的字符串，即string
        print(match.group()) #输出匹配的数据

        #search方法可以搜索字符串中第一个可以匹配的子串，返回一个match对象
        match=re.search(pattern,string,re.I) #不区分大小写匹配字符串，返回一个match对象

        #findall和finditer方法可以搜索字符串中所有可以匹配的子串
        match = re.findall(pattern,string,re.I) #不区分大小写匹配字符串，返回一个match对象
        print(match) #输出匹配子串的列表
        match = re.finditer(pattern, string, re.I) #返回一个由match对象组成的迭代器

        #上面的代码可以通过编译模式字符串进行简化
        pattern = re.compile(r'mr_\w+', re.I)
        match = pattern.match(string)
        match = pattern.match(string)
        match = pattern.findall(string)
        match = pattern.finditer(string)

        #捕获组的使用
        pattern = re.compile(r'(\w+)-(\d+)-(\w+)')
        text = "abc-123-def"
        match = pattern.match(text) #这里使用方法与上面相同
        #match.group(0)为'abc-123-def', match.group(i)为第i个捕获组捕获的内容
        match = pattern.findall(text) #match = \lbrack(`abc', `123', `def')\rbrack
      \end{codeblock}

    \subsubsection{替换字符串}
      sub方法可以实现vim中批量搜索并替换字符串的操作。

      模板为:re.sub(pattern,repl,string,count,flags)
      \begin{itemize}
        \item pattern:模式字符串
        \item repl:替换后的子字符串
        \item string:原始字符串
        \item count:可选，最大替换次数，默认为0，表示替换所有的匹配
        \item flags:可选，见\autoref{tab:matching pattern}
      \end{itemize}

      \begin{codeblock}[language=python, caption={string substitution}]
        import re

        pattern = r'1[34578]\d{9}' #模式字符串
        string='电话号码是:13611111111'
        result=re.sub(pattern,'1xxxxxxxxxx',string)

        pattern = re.compile(r'(1[34578]\d)\d{8}')
        string = 'The phone numbers are:13611111111,15888888888,18333333333'
        result = pattern.sub(r'\1********', string) #这里\textbackslash 1表示第一个捕获组
        result = 'The phone numbers are:136********,158********,183********'
      \end{codeblock}

    \subsubsection{切分字符串}
      re.split方法可以根据正则表达式切分字符串，匹配正则表达式的子串将被当作分隔符，并将分割结果以列表的形式返回。

      模板为:re.split(pattern,string,\lbrack maxsplit\rbrack,\lbrack flags\rbrack)
      \begin{itemize}
        \item pattern:模式字符串
        \item string:待切分的字符串
        \item maxsplit:可选，最大拆分次数
        \item flags:可选，见\autoref{tab:matching pattern}
      \end{itemize}
      \begin{codeblock}[language=python, caption={string segmentation}]
        import re

        pattern=r'[?&]'
        url='http://www.mingrisoft.com/login.jsp?username="mr"&pwd="mrsoft"'
        result=re.split(pattern,url)
        print(result)
      \end{codeblock}
